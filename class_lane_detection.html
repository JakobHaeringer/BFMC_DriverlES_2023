<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Raspberry Pi Platform: LaneDetection Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Raspberry Pi Platform
   &#160;<span id="projectnumber">v1.0</span>
   </div>
   <div id="projectbrief">This is the documentation of the source code which is running on the Raspberry Pi 4 Model B, that is responsible for sensing, planning and acting of the vehicle.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_lane_detection.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_lane_detection-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">LaneDetection Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class implements the lane search algorithm.  
 <a href="class_lane_detection.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_lane_detection_8hpp_source.html">LaneDetection.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for LaneDetection:</div>
<div class="dyncontent">
<div class="center"><img src="class_lane_detection__coll__graph.png" border="0" usemap="#a_lane_detection_coll__map" alt="Collaboration graph"/></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a731f54ebd16a6ad77ff51e413415d1d9"><td class="memItemLeft" align="right" valign="top"><a id="a731f54ebd16a6ad77ff51e413415d1d9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lane_detection.html#a731f54ebd16a6ad77ff51e413415d1d9">LaneDetection</a> ()</td></tr>
<tr class="memdesc:a731f54ebd16a6ad77ff51e413415d1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard constructor to construct a new <a class="el" href="class_lane_detection.html#a731f54ebd16a6ad77ff51e413415d1d9" title="Standard constructor to construct a new LaneDetection::LaneDetection object.">LaneDetection::LaneDetection</a> object. <br /></td></tr>
<tr class="separator:a731f54ebd16a6ad77ff51e413415d1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f6bd92995952d5baba44fdccd6dad1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lane_detection.html#ad6f6bd92995952d5baba44fdccd6dad1">LaneDetection</a> (cv::Mat _oriImage, cv::Mat _perspectiveMatrix)</td></tr>
<tr class="memdesc:ad6f6bd92995952d5baba44fdccd6dad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="class_lane_detection.html#a731f54ebd16a6ad77ff51e413415d1d9" title="Standard constructor to construct a new LaneDetection::LaneDetection object.">LaneDetection::LaneDetection</a> object.  <a href="class_lane_detection.html#ad6f6bd92995952d5baba44fdccd6dad1">More...</a><br /></td></tr>
<tr class="separator:ad6f6bd92995952d5baba44fdccd6dad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdccabf18bc0137fafb973624e8c3df3"><td class="memItemLeft" align="right" valign="top"><a id="afdccabf18bc0137fafb973624e8c3df3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lane_detection.html#afdccabf18bc0137fafb973624e8c3df3">~LaneDetection</a> ()</td></tr>
<tr class="memdesc:afdccabf18bc0137fafb973624e8c3df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the lane <a class="el" href="struct_detection.html" title="Holds all the attributes which are relevant for a detected object.">Detection</a> object. <br /></td></tr>
<tr class="separator:afdccabf18bc0137fafb973624e8c3df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f67f11589b578831c55018f374ee354"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lane_detection.html#a0f67f11589b578831c55018f374ee354">laneDetectAlgo</a> ()</td></tr>
<tr class="memdesc:a0f67f11589b578831c55018f374ee354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main function executing the preprocessing routine and calling necessary functions for detecting lanes.  <a href="class_lane_detection.html#a0f67f11589b578831c55018f374ee354">More...</a><br /></td></tr>
<tr class="separator:a0f67f11589b578831c55018f374ee354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa002e0e74510ecc1e518461a5abcec97"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lane.html#gaa002e0e74510ecc1e518461a5abcec97">getEdgeDetectResult</a> ()</td></tr>
<tr class="memdesc:gaa002e0e74510ecc1e518461a5abcec97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current canny edge image.  <a href="group___lane.html#gaa002e0e74510ecc1e518461a5abcec97">More...</a><br /></td></tr>
<tr class="separator:gaa002e0e74510ecc1e518461a5abcec97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fb2fff71a0d0e3080a7fd619e18131f"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lane.html#ga1fb2fff71a0d0e3080a7fd619e18131f">getWarpEdgeDetectResult</a> ()</td></tr>
<tr class="memdesc:ga1fb2fff71a0d0e3080a7fd619e18131f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the birds eye view of the current canny edge image.  <a href="group___lane.html#ga1fb2fff71a0d0e3080a7fd619e18131f">More...</a><br /></td></tr>
<tr class="separator:ga1fb2fff71a0d0e3080a7fd619e18131f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5224bc6dcf355fb6de602c811a6f4204"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lane.html#ga5224bc6dcf355fb6de602c811a6f4204">getGreenChannel</a> ()</td></tr>
<tr class="memdesc:ga5224bc6dcf355fb6de602c811a6f4204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the green channel of the current image.  <a href="group___lane.html#ga5224bc6dcf355fb6de602c811a6f4204">More...</a><br /></td></tr>
<tr class="separator:ga5224bc6dcf355fb6de602c811a6f4204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5bf59b46bf0bc361d60b531d07dc2f4"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lane.html#gab5bf59b46bf0bc361d60b531d07dc2f4">getGreenBinary</a> ()</td></tr>
<tr class="memdesc:gab5bf59b46bf0bc361d60b531d07dc2f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the green binary image.  <a href="group___lane.html#gab5bf59b46bf0bc361d60b531d07dc2f4">More...</a><br /></td></tr>
<tr class="separator:gab5bf59b46bf0bc361d60b531d07dc2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3cdf8d0e8eb7bc789621d3406a61601"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lane.html#gac3cdf8d0e8eb7bc789621d3406a61601">getMergeImage</a> ()</td></tr>
<tr class="memdesc:gac3cdf8d0e8eb7bc789621d3406a61601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the merged image of the green binary image and the canny edge image.  <a href="group___lane.html#gac3cdf8d0e8eb7bc789621d3406a61601">More...</a><br /></td></tr>
<tr class="separator:gac3cdf8d0e8eb7bc789621d3406a61601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab565075f58078a1347d17b9a5f952a6b"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lane.html#gab565075f58078a1347d17b9a5f952a6b">getHistImage</a> ()</td></tr>
<tr class="memdesc:gab565075f58078a1347d17b9a5f952a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the histogram of the counted white pixels per column.  <a href="group___lane.html#gab565075f58078a1347d17b9a5f952a6b">More...</a><br /></td></tr>
<tr class="separator:gab565075f58078a1347d17b9a5f952a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bf56138c8fcb99908b72c464b4dfb7f"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lane.html#ga4bf56138c8fcb99908b72c464b4dfb7f">getMaskImage</a> ()</td></tr>
<tr class="separator:ga4bf56138c8fcb99908b72c464b4dfb7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8a42792660b7efd70497127ed4c5589"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lane.html#gab8a42792660b7efd70497127ed4c5589">getWarpMask</a> ()</td></tr>
<tr class="separator:gab8a42792660b7efd70497127ed4c5589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf90e27a5fa76aa16ab0924cde3e6d588"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lane.html#gaf90e27a5fa76aa16ab0924cde3e6d588">getFinalResult</a> ()</td></tr>
<tr class="separator:gaf90e27a5fa76aa16ab0924cde3e6d588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7532f32f64429f1195f8e2b45758a02"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lane_detection.html#aa7532f32f64429f1195f8e2b45758a02">getLaneCenterDist</a> ()</td></tr>
<tr class="memdesc:aa7532f32f64429f1195f8e2b45758a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the distance the car has to the road center.  <a href="class_lane_detection.html#aa7532f32f64429f1195f8e2b45758a02">More...</a><br /></td></tr>
<tr class="separator:aa7532f32f64429f1195f8e2b45758a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16177e4727e94127e0837545173be06b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lane_detection.html#a16177e4727e94127e0837545173be06b">getCurveCoefficient</a> ()</td></tr>
<tr class="memdesc:a16177e4727e94127e0837545173be06b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the quadratic polynomial coefficient.  <a href="class_lane_detection.html#a16177e4727e94127e0837545173be06b">More...</a><br /></td></tr>
<tr class="separator:a16177e4727e94127e0837545173be06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ddcacc80639187fc211f42bb2ff3e25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lane_detection.html#a4ddcacc80639187fc211f42bb2ff3e25">setInputImage</a> (const cv::Mat &amp;image)</td></tr>
<tr class="memdesc:a4ddcacc80639187fc211f42bb2ff3e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the frame, in which the algorithm will try to detect lanes.  <a href="class_lane_detection.html#a4ddcacc80639187fc211f42bb2ff3e25">More...</a><br /></td></tr>
<tr class="separator:a4ddcacc80639187fc211f42bb2ff3e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6746be9c126b251f1460868cc93e8b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lane_detection.html#abb6746be9c126b251f1460868cc93e8b">toLaneDetectionMessage</a> (float distToMid, float curveCoeff)</td></tr>
<tr class="memdesc:abb6746be9c126b251f1460868cc93e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string of the current distance to the road center and the curve coefficient.  <a href="class_lane_detection.html#abb6746be9c126b251f1460868cc93e8b">More...</a><br /></td></tr>
<tr class="separator:abb6746be9c126b251f1460868cc93e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7047d1fa02e2241f7a20acfd183d341e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lane_detection.html#a7047d1fa02e2241f7a20acfd183d341e">getLaneCurvaturePos</a> ()</td></tr>
<tr class="memdesc:a7047d1fa02e2241f7a20acfd183d341e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the column at which the lane search has started in the current frame.  <a href="class_lane_detection.html#a7047d1fa02e2241f7a20acfd183d341e">More...</a><br /></td></tr>
<tr class="separator:a7047d1fa02e2241f7a20acfd183d341e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6680d770c3b9a6c38c893fa5420743ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lane_detection.html#a6680d770c3b9a6c38c893fa5420743ce">getLaneDistancePos</a> ()</td></tr>
<tr class="memdesc:a6680d770c3b9a6c38c893fa5420743ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the column at which the lane is found in the area the algorithm looks for to find the distance to the road center.  <a href="class_lane_detection.html#a6680d770c3b9a6c38c893fa5420743ce">More...</a><br /></td></tr>
<tr class="separator:a6680d770c3b9a6c38c893fa5420743ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a997957c786ad634d5e925517674f19ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lane_detection.html#a997957c786ad634d5e925517674f19ce">calHist</a> ()</td></tr>
<tr class="memdesc:a997957c786ad634d5e925517674f19ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a histogram of the number of white pixels per column.  <a href="class_lane_detection.html#a997957c786ad634d5e925517674f19ce">More...</a><br /></td></tr>
<tr class="separator:a997957c786ad634d5e925517674f19ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4808f3d5e95a73cb2916b4f7dfcb536f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lane_detection.html#a4808f3d5e95a73cb2916b4f7dfcb536f">boundaryDetection</a> ()</td></tr>
<tr class="memdesc:a4808f3d5e95a73cb2916b4f7dfcb536f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify's the starting position of the lanes in the current frame.  <a href="class_lane_detection.html#a4808f3d5e95a73cb2916b4f7dfcb536f">More...</a><br /></td></tr>
<tr class="separator:a4808f3d5e95a73cb2916b4f7dfcb536f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae200d3bb5bcc79c16403928bdac9d7bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lane_detection.html#ae200d3bb5bcc79c16403928bdac9d7bb">laneSearch</a> (const int &amp;lanePos, std::vector&lt; cv::Point2f &gt; &amp;_line, int &amp;lanecount, std::vector&lt; cv::Point2f &gt; &amp;curvePoints, char dir)</td></tr>
<tr class="memdesc:ae200d3bb5bcc79c16403928bdac9d7bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vector of y values for each row whereas the y value is the position of the lane in that row.  <a href="class_lane_detection.html#ae200d3bb5bcc79c16403928bdac9d7bb">More...</a><br /></td></tr>
<tr class="separator:ae200d3bb5bcc79c16403928bdac9d7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef213a4d82988d59e9a91f1f902f43b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lane_detection.html#aef213a4d82988d59e9a91f1f902f43b1">laneCoefEstimate</a> ()</td></tr>
<tr class="memdesc:aef213a4d82988d59e9a91f1f902f43b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates the coefficients of the 3rd degree polynomial that fits the detected lane the best.  <a href="class_lane_detection.html#aef213a4d82988d59e9a91f1f902f43b1">More...</a><br /></td></tr>
<tr class="separator:aef213a4d82988d59e9a91f1f902f43b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82cac619e0b8b9280c7a521ac9338cd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lane_detection.html#a82cac619e0b8b9280c7a521ac9338cd0">laneFitting</a> ()</td></tr>
<tr class="memdesc:a82cac619e0b8b9280c7a521ac9338cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the third degree polynomial with the estimated coefficients for every X-Value.  <a href="class_lane_detection.html#a82cac619e0b8b9280c7a521ac9338cd0">More...</a><br /></td></tr>
<tr class="separator:a82cac619e0b8b9280c7a521ac9338cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:gaec143f9b5d019f0ff9962e78198fb2be"><td class="memItemLeft" align="right" valign="top">
cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lane_detection_group1.html#gaec143f9b5d019f0ff9962e78198fb2be">perspectiveMatrix</a></td></tr>
<tr class="memdesc:gaec143f9b5d019f0ff9962e78198fb2be"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matrix that is used to transform the camera frame into the birds eye view. <br /></td></tr>
<tr class="separator:gaec143f9b5d019f0ff9962e78198fb2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7b230d669474144081fa4ef7a494a21"><td class="memItemLeft" align="right" valign="top">
cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lane_detection_group1.html#gae7b230d669474144081fa4ef7a494a21">originalImage</a></td></tr>
<tr class="memdesc:gae7b230d669474144081fa4ef7a494a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">The most current RGB camera frame in its original format. <br /></td></tr>
<tr class="separator:gae7b230d669474144081fa4ef7a494a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04ba2f4718e033e129b1a126d4ca9502"><td class="memItemLeft" align="right" valign="top">
cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lane_detection_group1.html#ga04ba2f4718e033e129b1a126d4ca9502">warpOriginalImage</a></td></tr>
<tr class="memdesc:ga04ba2f4718e033e129b1a126d4ca9502"><td class="mdescLeft">&#160;</td><td class="mdescRight">The birds eye view transformed original RGB frame. <br /></td></tr>
<tr class="separator:ga04ba2f4718e033e129b1a126d4ca9502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga671827082a7272ba390ad5e6496e54cc"><td class="memItemLeft" align="right" valign="top">
cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lane_detection_group1.html#ga671827082a7272ba390ad5e6496e54cc">warpEdgeImage</a></td></tr>
<tr class="memdesc:ga671827082a7272ba390ad5e6496e54cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The resulting frame of the canny edge detection of the birds eye view. <br /></td></tr>
<tr class="separator:ga671827082a7272ba390ad5e6496e54cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15c61a5acfcc2ffcb8492135b72204a4"><td class="memItemLeft" align="right" valign="top">
std::vector&lt; cv::Mat &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lane_detection_group1.html#ga15c61a5acfcc2ffcb8492135b72204a4">imageChannels</a></td></tr>
<tr class="memdesc:ga15c61a5acfcc2ffcb8492135b72204a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector holds the separate color channels of the original frame. <br /></td></tr>
<tr class="separator:ga15c61a5acfcc2ffcb8492135b72204a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae646defc568415f0c638cdc96c6e2018"><td class="memItemLeft" align="right" valign="top">
cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lane_detection_group1.html#gae646defc568415f0c638cdc96c6e2018">GreenBinary</a></td></tr>
<tr class="memdesc:gae646defc568415f0c638cdc96c6e2018"><td class="mdescLeft">&#160;</td><td class="mdescRight">The binary frame of the green image channel. <br /></td></tr>
<tr class="separator:gae646defc568415f0c638cdc96c6e2018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea62327852917d36fe87eaac02466439"><td class="memItemLeft" align="right" valign="top">
cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lane_detection_group1.html#gaea62327852917d36fe87eaac02466439">mergeImage</a></td></tr>
<tr class="memdesc:gaea62327852917d36fe87eaac02466439"><td class="mdescLeft">&#160;</td><td class="mdescRight">The merge image of the canny edge detection and the binary image of the green image channel. <br /></td></tr>
<tr class="separator:gaea62327852917d36fe87eaac02466439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2b7a621c148ca3ff068cf9ced56be5d"><td class="memItemLeft" align="right" valign="top">
cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lane_detection_group1.html#gaa2b7a621c148ca3ff068cf9ced56be5d">histogramImage</a></td></tr>
<tr class="memdesc:gaa2b7a621c148ca3ff068cf9ced56be5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A frame that shows the histogram of the detected white pixels per column. <br /></td></tr>
<tr class="separator:gaa2b7a621c148ca3ff068cf9ced56be5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga354b95ae9a2ba20dcb2ba77e2858fd87"><td class="memItemLeft" align="right" valign="top">
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lane_detection_group2.html#ga354b95ae9a2ba20dcb2ba77e2858fd87">histogramDistance</a></td></tr>
<tr class="memdesc:ga354b95ae9a2ba20dcb2ba77e2858fd87"><td class="mdescLeft">&#160;</td><td class="mdescRight">The histogram of the ROI for finding the distance of the car to the center of the lane. <br /></td></tr>
<tr class="separator:ga354b95ae9a2ba20dcb2ba77e2858fd87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43ac9bdfcaa61d6c8e6fabe27b0db9d1"><td class="memItemLeft" align="right" valign="top">
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lane_detection_group2.html#ga43ac9bdfcaa61d6c8e6fabe27b0db9d1">histogramCurvature</a></td></tr>
<tr class="memdesc:ga43ac9bdfcaa61d6c8e6fabe27b0db9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The histogram of the ROI for finding the starting point of the lane at the bottom of the image. <br /></td></tr>
<tr class="separator:ga43ac9bdfcaa61d6c8e6fabe27b0db9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga105bb654ba64ce2be8c3411df0310dbd"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lane_detection_group2.html#ga105bb654ba64ce2be8c3411df0310dbd">midHeightDistance</a></td></tr>
<tr class="memdesc:ga105bb654ba64ce2be8c3411df0310dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The row in which the ROI is set for finding lanes to determine the distance to the road center. <br /></td></tr>
<tr class="separator:ga105bb654ba64ce2be8c3411df0310dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86f6fe4b17154934e3f61bd85eca7978"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lane_detection_group2.html#ga86f6fe4b17154934e3f61bd85eca7978">midHeightCurvature</a></td></tr>
<tr class="memdesc:ga86f6fe4b17154934e3f61bd85eca7978"><td class="mdescLeft">&#160;</td><td class="mdescRight">The row in which the ROI is set for finding the starting point of the lanes in the bottom of the image. <br /></td></tr>
<tr class="separator:ga86f6fe4b17154934e3f61bd85eca7978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9d34d76bd90ce3feaf4a53873e91c3a"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lane_detection_group2.html#gaf9d34d76bd90ce3feaf4a53873e91c3a">rightLaneDistancePos</a></td></tr>
<tr class="memdesc:gaf9d34d76bd90ce3feaf4a53873e91c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The column of the right lane boundary for determining the distance to the road center. <br /></td></tr>
<tr class="separator:gaf9d34d76bd90ce3feaf4a53873e91c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf63dc5e24084481bef3ee0c7cc15ffa2"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lane_detection_group2.html#gaf63dc5e24084481bef3ee0c7cc15ffa2">rightLaneCurvaturePos</a></td></tr>
<tr class="memdesc:gaf63dc5e24084481bef3ee0c7cc15ffa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The column of the right lane boundary for determining the starting point of the lane in the bottom of the frame. <br /></td></tr>
<tr class="separator:gaf63dc5e24084481bef3ee0c7cc15ffa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70c910673d7a2eb801c7723d8d3f95af"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lane_detection_group2.html#ga70c910673d7a2eb801c7723d8d3f95af">oldRightLaneCurvaturePos</a> = 0</td></tr>
<tr class="memdesc:ga70c910673d7a2eb801c7723d8d3f95af"><td class="mdescLeft">&#160;</td><td class="mdescRight">The column of the right lane boundary for determining the starting point of the lane in the bottom of the previous frame. <br /></td></tr>
<tr class="separator:ga70c910673d7a2eb801c7723d8d3f95af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd2e854ab98820abd2ff8944279be4e"><td class="memItemLeft" align="right" valign="top"><a id="a8dd2e854ab98820abd2ff8944279be4e"></a>
std::vector&lt; cv::Point2f &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lane_detection.html#a8dd2e854ab98820abd2ff8944279be4e">laneR</a></td></tr>
<tr class="memdesc:a8dd2e854ab98820abd2ff8944279be4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This vector holds the column values of the detected lane points. <br /></td></tr>
<tr class="separator:a8dd2e854ab98820abd2ff8944279be4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e43b297157c3ff11b1bae682e2a848"><td class="memItemLeft" align="right" valign="top"><a id="a07e43b297157c3ff11b1bae682e2a848"></a>
std::vector&lt; cv::Point2f &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lane_detection.html#a07e43b297157c3ff11b1bae682e2a848">curvePointsR</a></td></tr>
<tr class="memdesc:a07e43b297157c3ff11b1bae682e2a848"><td class="mdescLeft">&#160;</td><td class="mdescRight">This vector holds the y value from the estimated third degree parabola. <br /></td></tr>
<tr class="separator:a07e43b297157c3ff11b1bae682e2a848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca46fc4a67ab7793e2f9527748d35692"><td class="memItemLeft" align="right" valign="top"><a id="aca46fc4a67ab7793e2f9527748d35692"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lane_detection.html#aca46fc4a67ab7793e2f9527748d35692">laneRcount</a></td></tr>
<tr class="memdesc:aca46fc4a67ab7793e2f9527748d35692"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of detected lane pixels which is used as a threshold to reduce false detections. <br /></td></tr>
<tr class="separator:aca46fc4a67ab7793e2f9527748d35692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77fc5da729aeba87f2c7d9cac1c3486"><td class="memItemLeft" align="right" valign="top"><a id="aa77fc5da729aeba87f2c7d9cac1c3486"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lane_detection.html#aa77fc5da729aeba87f2c7d9cac1c3486">midPoint</a></td></tr>
<tr class="memdesc:aa77fc5da729aeba87f2c7d9cac1c3486"><td class="mdescLeft">&#160;</td><td class="mdescRight">The middle column of the image. <br /></td></tr>
<tr class="separator:aa77fc5da729aeba87f2c7d9cac1c3486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246610571827362da70316b893e96d51"><td class="memItemLeft" align="right" valign="top"><a id="a246610571827362da70316b893e96d51"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lane_detection.html#a246610571827362da70316b893e96d51">recordCounter</a> = 0</td></tr>
<tr class="memdesc:a246610571827362da70316b893e96d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">A counter that is used as iterator for the curveCoefRecordR vector. <br /></td></tr>
<tr class="separator:a246610571827362da70316b893e96d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617015e6dba263e29ea10f2df6124525"><td class="memItemLeft" align="right" valign="top"><a id="a617015e6dba263e29ea10f2df6124525"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lane_detection.html#a617015e6dba263e29ea10f2df6124525">stepY</a></td></tr>
<tr class="memdesc:a617015e6dba263e29ea10f2df6124525"><td class="mdescLeft">&#160;</td><td class="mdescRight">The step size that is used for skipping columns in the current searching window to save performance time. <br /></td></tr>
<tr class="separator:a617015e6dba263e29ea10f2df6124525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96de802998ddfccfb8f59852b8f2557b"><td class="memItemLeft" align="right" valign="top"><a id="a96de802998ddfccfb8f59852b8f2557b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lane_detection.html#a96de802998ddfccfb8f59852b8f2557b">detectedWindows</a> = 0</td></tr>
<tr class="memdesc:a96de802998ddfccfb8f59852b8f2557b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A counter to stop the lane search when there is no lane detected in a few consecutive search windows. <br /></td></tr>
<tr class="separator:a96de802998ddfccfb8f59852b8f2557b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a0cbdbd78765717149643454eb3e6b"><td class="memItemLeft" align="right" valign="top"><a id="ad9a0cbdbd78765717149643454eb3e6b"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lane_detection.html#ad9a0cbdbd78765717149643454eb3e6b">initRecordCount</a> = 0</td></tr>
<tr class="memdesc:ad9a0cbdbd78765717149643454eb3e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A counter used to signal the algorithm that it can start to average the new curve coefficients with the past five ones. <br /></td></tr>
<tr class="separator:ad9a0cbdbd78765717149643454eb3e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeffe38eddfec35db8f73f4a59f170844"><td class="memItemLeft" align="right" valign="top"><a id="aeffe38eddfec35db8f73f4a59f170844"></a>
Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lane_detection.html#aeffe38eddfec35db8f73f4a59f170844">curveCoefR</a></td></tr>
<tr class="memdesc:aeffe38eddfec35db8f73f4a59f170844"><td class="mdescLeft">&#160;</td><td class="mdescRight">The coefficients as a result of the estimation of the parabola for the detected current lane. <br /></td></tr>
<tr class="separator:aeffe38eddfec35db8f73f4a59f170844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2be49d0e3c481efdff568f9eb0c7c71"><td class="memItemLeft" align="right" valign="top"><a id="aa2be49d0e3c481efdff568f9eb0c7c71"></a>
Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lane_detection.html#aa2be49d0e3c481efdff568f9eb0c7c71">curveCoefRecordR</a> [5]</td></tr>
<tr class="memdesc:aa2be49d0e3c481efdff568f9eb0c7c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector holds the past five resulting coefficients to smoothen out the result of the current calculation. <br /></td></tr>
<tr class="separator:aa2be49d0e3c481efdff568f9eb0c7c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a097e64d9c8332d9fbaf54ad61a392c63"><td class="memItemLeft" align="right" valign="top"><a id="a097e64d9c8332d9fbaf54ad61a392c63"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lane_detection.html#a097e64d9c8332d9fbaf54ad61a392c63">laneOffset</a> = 0.0f</td></tr>
<tr class="memdesc:a097e64d9c8332d9fbaf54ad61a392c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">The offset that is added to the distance to the road center when the left lane is detected instead of the right. <br /></td></tr>
<tr class="separator:a097e64d9c8332d9fbaf54ad61a392c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43c869944427a0ff42471e1552402a8"><td class="memItemLeft" align="right" valign="top"><a id="ab43c869944427a0ff42471e1552402a8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>failDetectFlag</b> = true</td></tr>
<tr class="separator:ab43c869944427a0ff42471e1552402a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe98616e7426475cdb766f8b42f44a4"><td class="memItemLeft" align="right" valign="top"><a id="a4fe98616e7426475cdb766f8b42f44a4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>updateValues</b> = false</td></tr>
<tr class="separator:a4fe98616e7426475cdb766f8b42f44a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1b1aad0f661860a409c7b83ef48d8b"><td class="memItemLeft" align="right" valign="top"><a id="a6a1b1aad0f661860a409c7b83ef48d8b"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>oldResult</b> = 0.0f</td></tr>
<tr class="separator:a6a1b1aad0f661860a409c7b83ef48d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d68d994430416eb3a613e6e540f551"><td class="memItemLeft" align="right" valign="top"><a id="af0d68d994430416eb3a613e6e540f551"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>oldLaneOffset</b> = 0.0f</td></tr>
<tr class="separator:af0d68d994430416eb3a613e6e540f551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840fe65a56c7399b2456b6d1a5c774b0"><td class="memItemLeft" align="right" valign="top"><a id="a840fe65a56c7399b2456b6d1a5c774b0"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>blockNum</b></td></tr>
<tr class="separator:a840fe65a56c7399b2456b6d1a5c774b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca74f1cce009f9e113d8034d197cd60a"><td class="memItemLeft" align="right" valign="top"><a id="aca74f1cce009f9e113d8034d197cd60a"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>windowSize</b></td></tr>
<tr class="separator:aca74f1cce009f9e113d8034d197cd60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66803fbfd7bdde96b5c0d1a83c68da1"><td class="memItemLeft" align="right" valign="top"><a id="ae66803fbfd7bdde96b5c0d1a83c68da1"></a>
cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><b>mergeImageRGB</b></td></tr>
<tr class="separator:ae66803fbfd7bdde96b5c0d1a83c68da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267e4e325bf65e06461a95eb473aa9ac"><td class="memItemLeft" align="right" valign="top"><a id="a267e4e325bf65e06461a95eb473aa9ac"></a>
cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><b>edgeImage</b></td></tr>
<tr class="separator:a267e4e325bf65e06461a95eb473aa9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e9d057b2be3a3caf26232ba3c005f6"><td class="memItemLeft" align="right" valign="top"><a id="a63e9d057b2be3a3caf26232ba3c005f6"></a>
cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><b>maskImage</b></td></tr>
<tr class="separator:a63e9d057b2be3a3caf26232ba3c005f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afddbd774c30ea20c26500198291d04fc"><td class="memItemLeft" align="right" valign="top"><a id="afddbd774c30ea20c26500198291d04fc"></a>
cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><b>finalResult</b></td></tr>
<tr class="separator:afddbd774c30ea20c26500198291d04fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7c9b09bba4ed6a69f5cf4a3caac5a4"><td class="memItemLeft" align="right" valign="top"><a id="a8e7c9b09bba4ed6a69f5cf4a3caac5a4"></a>
cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><b>maskImageWarp</b></td></tr>
<tr class="separator:a8e7c9b09bba4ed6a69f5cf4a3caac5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4e17c1f6ec5e3e7b89aa856766693e"><td class="memItemLeft" align="right" valign="top"><a id="a6c4e17c1f6ec5e3e7b89aa856766693e"></a>
std::chrono::high_resolution_clock::time_point&#160;</td><td class="memItemRight" valign="bottom"><b>tStart</b></td></tr>
<tr class="separator:a6c4e17c1f6ec5e3e7b89aa856766693e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c52daa3dd1ea5713c4bc54cf2e359b"><td class="memItemLeft" align="right" valign="top"><a id="ad8c52daa3dd1ea5713c4bc54cf2e359b"></a>
std::chrono::high_resolution_clock::time_point&#160;</td><td class="memItemRight" valign="bottom"><b>tEnd</b></td></tr>
<tr class="separator:ad8c52daa3dd1ea5713c4bc54cf2e359b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6455ef52ccf3d893026f2d87ead1d7"><td class="memItemLeft" align="right" valign="top"><a id="a7a6455ef52ccf3d893026f2d87ead1d7"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>result</b> = 0.0f</td></tr>
<tr class="separator:a7a6455ef52ccf3d893026f2d87ead1d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class implements the lane search algorithm. </p>
<p>It is based on a simple, but fast sliding window search. From the X- and Y-values found during this search, a singular value decomposition (SVD) is performed to find the best fitting coefficients for a third degree polynomial that fits the shape of the detected lane. The result of this calculation, as well as the distance of the car to the center of the road ahead is then built into a string message which can be communicated to other processes. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad6f6bd92995952d5baba44fdccd6dad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f6bd92995952d5baba44fdccd6dad1">&#9670;&nbsp;</a></span>LaneDetection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LaneDetection::LaneDetection </td>
          <td>(</td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>_oriImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>_perspectiveMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="class_lane_detection.html#a731f54ebd16a6ad77ff51e413415d1d9" title="Standard constructor to construct a new LaneDetection::LaneDetection object.">LaneDetection::LaneDetection</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_oriImage</td><td>The most current camera frame </td></tr>
    <tr><td class="paramname">_perspectiveMatrix</td><td>The rotation matrix that will be used for the birds eye view transformation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4808f3d5e95a73cb2916b4f7dfcb536f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4808f3d5e95a73cb2916b4f7dfcb536f">&#9670;&nbsp;</a></span>boundaryDetection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LaneDetection::boundaryDetection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identify's the starting position of the lanes in the current frame. </p>
<p>Depending on the column with the most white pixels in the specific ROI, the position of the lane gets set. Since we used a camera with a small field of view, we are aiming for only detecting one lane at a time. The function will at first look at the right half of the transformed image. If no lane can be found according to the given searching rules, the function will look in the left half of the image. Depending on the previous results it will determine if the detected lane is the median strip of the road, or the right outer lane and add an offset to the distance to the middle of the road. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_lane_detection_a4808f3d5e95a73cb2916b4f7dfcb536f_cgraph.png" border="0" usemap="#aclass_lane_detection_a4808f3d5e95a73cb2916b4f7dfcb536f_cgraph" alt=""/></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_lane_detection_a4808f3d5e95a73cb2916b4f7dfcb536f_icgraph.png" border="0" usemap="#aclass_lane_detection_a4808f3d5e95a73cb2916b4f7dfcb536f_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a997957c786ad634d5e925517674f19ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a997957c786ad634d5e925517674f19ce">&#9670;&nbsp;</a></span>calHist()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LaneDetection::calHist </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a histogram of the number of white pixels per column. </p>
<p>To later identify the starting position of the lane search, the amount of white pixels in each column of the binary frame are being counted. Those values then are stored in two dimensional vectors. Since not all rows of pixel are needed there are two region of interests (ROI) defined. One for finding the start of the lanes and one for identifying the delta distance to the middle of the road. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_lane_detection_a997957c786ad634d5e925517674f19ce_icgraph.png" border="0" usemap="#aclass_lane_detection_a997957c786ad634d5e925517674f19ce_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a16177e4727e94127e0837545173be06b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16177e4727e94127e0837545173be06b">&#9670;&nbsp;</a></span>getCurveCoefficient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LaneDetection::getCurveCoefficient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the quadratic polynomial coefficient. </p>
<dl class="section return"><dt>Returns</dt><dd>float Holds the coefficient value, usually has values bellow 1 </dd></dl>

</div>
</div>
<a id="aa7532f32f64429f1195f8e2b45758a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7532f32f64429f1195f8e2b45758a02">&#9670;&nbsp;</a></span>getLaneCenterDist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LaneDetection::getLaneCenterDist </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the distance the car has to the road center. </p>
<dl class="section return"><dt>Returns</dt><dd>float Holds the distance in meter </dd></dl>

</div>
</div>
<a id="a7047d1fa02e2241f7a20acfd183d341e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7047d1fa02e2241f7a20acfd183d341e">&#9670;&nbsp;</a></span>getLaneCurvaturePos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LaneDetection::getLaneCurvaturePos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the column at which the lane search has started in the current frame. </p>
<dl class="section return"><dt>Returns</dt><dd>int Column of the lane position, somewhere between 0 and 400 </dd></dl>

</div>
</div>
<a id="a6680d770c3b9a6c38c893fa5420743ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6680d770c3b9a6c38c893fa5420743ce">&#9670;&nbsp;</a></span>getLaneDistancePos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LaneDetection::getLaneDistancePos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the column at which the lane is found in the area the algorithm looks for to find the distance to the road center. </p>
<dl class="section return"><dt>Returns</dt><dd>int Column of the lane position, somewhere between 0 and 400 </dd></dl>

</div>
</div>
<a id="aef213a4d82988d59e9a91f1f902f43b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef213a4d82988d59e9a91f1f902f43b1">&#9670;&nbsp;</a></span>laneCoefEstimate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LaneDetection::laneCoefEstimate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Estimates the coefficients of the 3rd degree polynomial that fits the detected lane the best. </p>
<dl class="section return"><dt>Returns</dt><dd>true A estimation of the lane curvature was made </dd>
<dd>
false Not enough pixels of the lane could be found for a precise estimation</dd></dl>
<p>For a good result the function creates a linear system and solves it using SVD </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_lane_detection_aef213a4d82988d59e9a91f1f902f43b1_icgraph.png" border="0" usemap="#aclass_lane_detection_aef213a4d82988d59e9a91f1f902f43b1_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a0f67f11589b578831c55018f374ee354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f67f11589b578831c55018f374ee354">&#9670;&nbsp;</a></span>laneDetectAlgo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LaneDetection::laneDetectAlgo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main function executing the preprocessing routine and calling necessary functions for detecting lanes. </p>
<p>This function is the main function of the lane detection class. This means that all the necessary functions for the lane detection are beeing executed from here. Starting with the preprocessing routine, which consists of creating the birds eye view through a perspective warp, then gray scaling the frame, next removing noise by adding a gaussian blur to the image and then detecting the edges with a canny edge detection. After that the image will be transformed into a binary image. For better error tolerance a second image gets created that, by using the green color channel of the original frame gets transformed into a binary image. After the preprocessing the lane detection is executed. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_lane_detection_a0f67f11589b578831c55018f374ee354_cgraph.png" border="0" usemap="#aclass_lane_detection_a0f67f11589b578831c55018f374ee354_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a82cac619e0b8b9280c7a521ac9338cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82cac619e0b8b9280c7a521ac9338cd0">&#9670;&nbsp;</a></span>laneFitting()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LaneDetection::laneFitting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves the third degree polynomial with the estimated coefficients for every X-Value. </p>
<p>To obtain a more stable result the new parabola coefficients are averaged over the past five results. This leads to reducing the effect of e.g. a wrong detected lane in a single frame because of noise or reflections. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_lane_detection_a82cac619e0b8b9280c7a521ac9338cd0_icgraph.png" border="0" usemap="#aclass_lane_detection_a82cac619e0b8b9280c7a521ac9338cd0_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="ae200d3bb5bcc79c16403928bdac9d7bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae200d3bb5bcc79c16403928bdac9d7bb">&#9670;&nbsp;</a></span>laneSearch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LaneDetection::laneSearch </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>lanePos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cv::Point2f &gt; &amp;&#160;</td>
          <td class="paramname"><em>_line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>lanecount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cv::Point2f &gt; &amp;&#160;</td>
          <td class="paramname"><em>curvePoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a vector of y values for each row whereas the y value is the position of the lane in that row. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lanePos</td><td>Y-position to start the lane search at </td></tr>
    <tr><td class="paramname">_line</td><td>The vector that holds the resulting y-values </td></tr>
    <tr><td class="paramname">lanecount</td><td>The number of detected lane pixels </td></tr>
    <tr><td class="paramname">curvePoints</td><td>TODO: Not in use, check if it can be removed </td></tr>
    <tr><td class="paramname">dir</td><td>TODO: Not in use, check if it can be removed</td></tr>
  </table>
  </dd>
</dl>
<p>This function searches for the lane by using a searching box. This rectangle is used to delimit the searching area of the lane. It starts the search at the previously found starting point of the lane and then continues to iterate over the frame by moving the next searching box depending on the result of the previous one. When the function doesn't find the lane in the current searching window it will just move the next box on top of the previous one. If this happens three times in a row the function will terminate. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_lane_detection_ae200d3bb5bcc79c16403928bdac9d7bb_cgraph.png" border="0" usemap="#aclass_lane_detection_ae200d3bb5bcc79c16403928bdac9d7bb_cgraph" alt=""/></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_lane_detection_ae200d3bb5bcc79c16403928bdac9d7bb_icgraph.png" border="0" usemap="#aclass_lane_detection_ae200d3bb5bcc79c16403928bdac9d7bb_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a4ddcacc80639187fc211f42bb2ff3e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ddcacc80639187fc211f42bb2ff3e25">&#9670;&nbsp;</a></span>setInputImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LaneDetection::setInputImage </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>image</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the frame, in which the algorithm will try to detect lanes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>The matrix that holds the frame </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb6746be9c126b251f1460868cc93e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb6746be9c126b251f1460868cc93e8b">&#9670;&nbsp;</a></span>toLaneDetectionMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string LaneDetection::toLaneDetectionMessage </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>distToMid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>curveCoeff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string of the current distance to the road center and the curve coefficient. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">distToMid</td><td>Float value of the distance to the center of the road in meter </td></tr>
    <tr><td class="paramname">curveCoeff</td><td>Float value of the quadratic polynomial curve coefficient of the lane. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string A string in the format, so it can be sent to the RaspberryPi </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/bfmc_input/include/camera_perception/<a class="el" href="_lane_detection_8hpp_source.html">LaneDetection.hpp</a></li>
<li>src/bfmc_input/src/camera_perception/<a class="el" href="_lane_detection_8cpp.html">LaneDetection.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_lane_detection.html">LaneDetection</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
